<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Oscillator TSP Solver with Animation</title>
    <style>
        canvas { border: 1px solid black; }
        body { font-family: Arial, sans-serif; margin: 20px; }
        #description { max-width: 600px; margin-top: 20px; font-size: 14px; line-height: 1.5; }
    </style>
</head>
<body>
    <h1>TSP Solver with Oscillators</h1>
    <canvas id="tspCanvas" width="400" height="400"></canvas>
    <p id="result">Running...</p>
    <div id="description">
        <h2>What’s Happening?</h2>
        <p>This webpage uses a network of oscillators to solve the Traveling Salesman Problem (TSP) for 6 cities with random locations each reload. Here's how it works:</p>
        <ol>
            <li><strong>Initial Display:</strong> Six blue dots (cities) appear at random coordinates within the 400x400 canvas, labeled City 0 to City 5. Below, you see the iteration count, current tour, and shortest tour found so far (initially "N/A").</li>
            <li><strong>Animation Begins:</strong> Oscillators represent city-step assignments, starting undecided (0.5). They "vibrate" to minimize energy, balancing constraints (one city per step, one step per city) and tour length.</li>
            <li><strong>Evolving Tour:</strong> Red lines (current tour) start chaotic, evolving into a full tour (e.g., 0 -> 1 -> 2 -> 3 -> 4 -> 5). Green lines show the shortest tour found so far, updating as better solutions emerge.</li>
            <li><strong>Convergence:</strong> Around 500–1000 iterations, oscillators settle into a valid tour (e.g., length ~500–600 units, depending on city placement). The shortest tour often matches or improves on the final tour.</li>
            <li><strong>Visual Intuition:</strong> Red lines "dance" as oscillators synchronize, while green lines stabilize on the best solution, mimicking a physical system finding a low-energy state.</li>
        </ol>
        <p><em>Note:</em> This is a heuristic approximation; the final tour isn’t always optimal, but it shows oscillators converging. Reload to see a new random layout!</p>
    </div>
    <script>
        // TSP instance: 6 cities with random (x, y) coordinates
        const n = 6;
        const cities = Array(n).fill().map(() => [
            Math.random() * 350 + 25, // x: 25 to 375
            Math.random() * 350 + 25  // y: 25 to 375
        ]);

        // Distance matrix
        const distances = Array(n).fill().map(() => Array(n).fill(0));
        for (let i = 0; i < n; i++) {
            for (let j = 0; j < n; j++) {
                const dx = cities[i][0] - cities[j][0];
                const dy = cities[i][1] - cities[j][1];
                distances[i][j] = Math.sqrt(dx * dx + dy * dy);
            }
        }

        // Oscillator network: n x n matrix (city i at step j)
        let V = Array(n).fill().map(() => Array(n).fill(0.5)); // Initial state: neutral

        // Parameters
        const A = 500;  // Constraint penalty (one city per step)
        const B = 500;  // Constraint penalty (each step has one city)
        const D = 50;   // Distance cost
        const dt = 0.01; // Time step
        const maxIter = 2000; // Max iterations

        // Track shortest tour
        let shortestTour = null;
        let shortestLength = Infinity;

        // Energy update function
        function updateOscillators() {
            let dV = Array(n).fill().map(() => Array(n).fill(0));
            let converged = true;

            for (let i = 0; i < n; i++) {
                for (let x = 0; x < n; x++) {
                    let sumA = 0; // Row constraint
                    let sumB = 0; // Column constraint
                    let sumD = 0; // Distance term

                    for (let y = 0; y < n; y++) {
                        if (y !== x) sumA += V[i][y];
                    }

                    for (let k = 0; k < n; k++) {
                        if (k !== i) sumB += V[k][x];
                    }

                    for (let j = 0; j < n; j++) {
                        for (let y = 0; y < n; y++) {
                            if (y !== x) {
                                sumD += distances[i][j] * V[i][x] * V[j][(x + 1) % n];
                            }
                        }
                    }

                    dV[i][x] = -A * sumA - B * sumB - D * sumD;
                    let newV = V[i][x] + dt * dV[i][x];
                    newV = Math.max(0, Math.min(1, newV));
                    if (Math.abs(newV - V[i][x]) > 0.001) converged = false;
                    V[i][x] = newV;
                }
            }
            return converged;
        }

        // Extract tour from oscillator states
        function getTour() {
            let tour = Array(n).fill(-1);
            for (let x = 0; x < n; x++) {
                let maxVal = -1;
                let maxI = -1;
                for (let i = 0; i < n; i++) {
                    if (V[i][x] > maxVal && tour.indexOf(i) === -1) {
                        maxVal = V[i][x];
                        maxI = i;
                    }
                }
                if (maxI !== -1) tour[x] = maxI;
            }
            return tour;
        }

        // Calculate tour length
        function getTourLength(tour) {
            let length = 0;
            for (let x = 0; x < n; x++) {
                length += distances[tour[x]][tour[(x + 1) % n]];
            }
            return length;
        }

        // Canvas setup
        const canvas = document.getElementById('tspCanvas');
        const ctx = canvas.getContext('2d');

        // Draw function
        function drawTour(currentTour, iter) {
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // Draw cities
            ctx.fillStyle = 'blue';
            for (let i = 0; i < n; i++) {
                ctx.beginPath();
                ctx.arc(cities[i][0], cities[i][1], 5, 0, 2 * Math.PI);
                ctx.fill();
                ctx.fillText(`City ${i}`, cities[i][0] + 10, cities[i][1]);
            }

            // Draw shortest tour (green)
            if (shortestTour) {
                ctx.strokeStyle = 'green';
                ctx.lineWidth = 2;
                ctx.beginPath();
                for (let x = 0; x < n; x++) {
                    const city = shortestTour[x];
                    if (x === 0) {
                        ctx.moveTo(cities[city][0], cities[city][1]);
                    } else {
                        ctx.lineTo(cities[city][0], cities[city][1]);
                    }
                }
                ctx.lineTo(cities[shortestTour[0]][0], cities[shortestTour[0]][1]);
                ctx.stroke();
            }

            // Draw current tour (red)
            ctx.strokeStyle = 'red';
            ctx.lineWidth = 2;
            ctx.beginPath();
            for (let x = 0; x < n; x++) {
                const city = currentTour[x];
                if (city !== -1) {
                    if (x === 0) {
                        ctx.moveTo(cities[city][0], cities[city][1]);
                    } else {
                        ctx.lineTo(cities[city][0], cities[city][1]);
                    }
                }
            }
            if (currentTour[0] !== -1) ctx.lineTo(cities[currentTour[0]][0], cities[currentTour[0]][1]);
            ctx.stroke();

            // Update shortest tour and display
            let currentLength = 'N/A';
            let validCurrentTour = currentTour.every(city => city !== -1);
            if (validCurrentTour) {
                currentLength = getTourLength(currentTour).toFixed(2);
                if (currentLength < shortestLength) {
                    shortestTour = [...currentTour];
                    shortestLength = currentLength;
                }
            }
            document.getElementById('result').textContent = 
                `Iteration: ${iter} | Current: ${currentTour.join(' -> ')} (${currentLength}) | Shortest: ${shortestTour ? shortestTour.join(' -> ') : 'N/A'} (${shortestTour ? shortestLength : 'N/A'})`;
        }

        // Animation loop
        let iter = 0;
        function animate() {
            if (iter < maxIter && !updateOscillators()) {
                const currentTour = getTour();
                drawTour(currentTour, iter);
                iter++;
                requestAnimationFrame(animate);
            } else {
                const finalTour = getTour();
                drawTour(finalTour, iter);
                console.log("Converged at iteration:", iter);
            }
        }

        // Start animation
        animate();
    </script>
</body>
</html>
