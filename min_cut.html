<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8" />
  <title>Two-Subgraph Oscillator Synchronization</title>
  <style>
    body {
      font-family: sans-serif;
      margin: 20px;
    }
    #controls {
      margin-bottom: 10px;
    }
    #myCanvas {
      border: 1px solid #aaa;
      display: block;
      margin-top: 10px;
    }
  </style>
</head>
<body>
  <h2>Oscillator Synchronization with Two Subgraphs</h2>
  <p>
    This demo splits the oscillators into two subgraphs (each half), connects them internally
    with a chosen probability, and then adds a specified number of cross-edges between
    the subgraphs. The color of each node indicates its current phase.
  </p>
  <div id="controls">
    <label for="oscInput">Total Oscillators (even):</label>
    <input type="number" id="oscInput" value="20" min="2" max="200" step="2" />
    <label for="probInput">Intra-Subgraph p:</label>
    <input type="number" id="probInput" value="0.3" step="0.01" min="0" max="1" />
    <label for="crossInput">Cross-Edges:</label>
    <input type="number" id="crossInput" value="1" min="0" max="100" />
    <button id="initButton">Initialize</button>
  </div>
  <canvas id="myCanvas" width="600" height="600"></canvas>

  <script>
    // ===== Global Variables =====
    let numberOfOscillators;   // total oscillators (must be even)
    let subSize;               // numberOfOscillators / 2
    let intraProbability;      // Probability of edges within each subgraph
    let crossEdges;            // how many edges to add between subgraphs

    let adjacencyMatrix = [];  // 2D adjacency (0 or 1)
    let phases = [];           // array of phases
    let simulationInterval;    // handle for setInterval
    // Sim params
    const dt = 0.05;    // time step
    const coupling = 1; // coupling strength
    const updateFPS = 20; // ~ updates per second

    // Canvas stuff
    const canvas = document.getElementById('myCanvas');
    const ctx = canvas.getContext('2d');

    // Controls
    const oscInput = document.getElementById('oscInput');
    const probInput = document.getElementById('probInput');
    const crossInput = document.getElementById('crossInput');
    const initButton = document.getElementById('initButton');

    // ===== Utility Functions =====

    /**
     * Creates a random adjacency for 'numNodes' with probability p of an edge (undirected).
     * i -> j sets adjacency[i][j] = adjacency[j][i] = 1, if random < p.
     * No self-loops.
     */
    function createRandomAdjacency(numNodes, p) {
      const matrix = [];
      for (let i = 0; i < numNodes; i++) {
        matrix[i] = new Array(numNodes).fill(0);
      }
      for (let i = 0; i < numNodes; i++) {
        for (let j = i+1; j < numNodes; j++) {
          if (Math.random() < p) {
            matrix[i][j] = 1;
            matrix[j][i] = 1;
          }
        }
      }
      return matrix;
    }

    /**
     * Merges two adjacency matrices A, B (each subgraph) into a single adjacency matrix,
     * offsetting B's indices by sizeA. Adds 'crossCount' random edges between them.
     * sizeA = A.length, sizeB = B.length
     */
    function mergeSubgraphs(A, B, crossCount) {
      const sizeA = A.length;
      const sizeB = B.length;
      const total = sizeA + sizeB;

      // Initialize combined adjacency
      const combined = [];
      for (let i = 0; i < total; i++) {
        combined[i] = new Array(total).fill(0);
      }

      // Copy subgraph A
      for (let i = 0; i < sizeA; i++) {
        for (let j = 0; j < sizeA; j++) {
          combined[i][j] = A[i][j];
        }
      }
      // Copy subgraph B, offset by sizeA
      for (let i = 0; i < sizeB; i++) {
        for (let j = 0; j < sizeB; j++) {
          combined[sizeA + i][sizeA + j] = B[i][j];
        }
      }

      // Add cross edges
      let edgesAdded = 0;
      while (edgesAdded < crossCount) {
        const a = Math.floor(Math.random() * sizeA);
        const b = sizeA + Math.floor(Math.random() * sizeB);
        // if no existing edge
        if (combined[a][b] === 0) {
          combined[a][b] = 1;
          combined[b][a] = 1;
          edgesAdded++;
        }
      }

      return combined;
    }

    /**
     * Initialize random phases in [0, 2π)
     */
    function randomPhases(numOsc) {
      const arr = new Array(numOsc);
      for (let i = 0; i < numOsc; i++) {
        arr[i] = 2 * Math.PI * Math.random();
      }
      return arr;
    }

    /**
     * Single Kuramoto-like update:
     * θ_i(t+1) = θ_i(t) + dt * K * Σ sin(θ_j - θ_i) for all j where adjacency[i][j] = 1
     */
    function updatePhases() {
      const newPhases = new Array(numberOfOscillators);
      for (let i = 0; i < numberOfOscillators; i++) {
        let sumCoupling = 0;
        for (let j = 0; j < numberOfOscillators; j++) {
          if (adjacencyMatrix[i][j] === 1) {
            sumCoupling += Math.sin(phases[j] - phases[i]);
          }
        }
        newPhases[i] = phases[i] + dt * coupling * sumCoupling;
      }
      phases = newPhases;
    }

    /**
     * Render the network on the canvas:
     * - Place nodes in a circle
     * - Draw edges
     * - Color nodes by their current phase
     */
    function drawNetwork() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      const centerX = canvas.width / 2;
      const centerY = canvas.height / 2;
      const radius = canvas.width * 0.38;

      // node positions
      const coords = [];
      for (let i = 0; i < numberOfOscillators; i++) {
        const angle = (2 * Math.PI * i) / numberOfOscillators;
        const x = centerX + radius * Math.cos(angle);
        const y = centerY + radius * Math.sin(angle);
        coords.push({ x, y });
      }

      // edges
      ctx.strokeStyle = 'rgba(0,0,0,0.15)';
      for (let i = 0; i < numberOfOscillators; i++) {
        for (let j = i+1; j < numberOfOscillators; j++) {
          if (adjacencyMatrix[i][j] === 1) {
            ctx.beginPath();
            ctx.moveTo(coords[i].x, coords[i].y);
            ctx.lineTo(coords[j].x, coords[j].y);
            ctx.stroke();
          }
        }
      }

      // nodes
      const nodeRadius = 8;
      for (let i = 0; i < numberOfOscillators; i++) {
        // map phase -> hue
        let hue = (phases[i] * 180 / Math.PI) % 360;
        ctx.fillStyle = `hsl(${hue}, 100%, 50%)`;
        ctx.beginPath();
        ctx.arc(coords[i].x, coords[i].y, nodeRadius, 0, 2*Math.PI);
        ctx.fill();
      }
    }

    /**
     * Single simulation step: update phases, then draw
     */
    function step() {
      updatePhases();
      drawNetwork();
    }

    function initializeSimulation() {
      // clear old interval
      if (simulationInterval) {
        clearInterval(simulationInterval);
      }

      // parse user inputs
      numberOfOscillators = parseInt(oscInput.value, 10);
      if (numberOfOscillators < 2) numberOfOscillators = 2;
      if (numberOfOscillators % 2 !== 0) {
        alert("Please enter an even number of oscillators.");
        return;
      }
      intraProbability = parseFloat(probInput.value);
      crossEdges = parseInt(crossInput.value, 10);

      subSize = numberOfOscillators / 2;

      // Create subgraph A
      const A = createRandomAdjacency(subSize, intraProbability);
      // Create subgraph B
      const B = createRandomAdjacency(subSize, intraProbability);
      // Merge them with crossEdges
      adjacencyMatrix = mergeSubgraphs(A, B, crossEdges);

      phases = randomPhases(numberOfOscillators);

      drawNetwork();
      simulationInterval = setInterval(step, 1000 / updateFPS);
    }

    // Event
    initButton.addEventListener('click', initializeSimulation);

    // Initialize once on load
    initializeSimulation();
  </script>
</body>
</html>
