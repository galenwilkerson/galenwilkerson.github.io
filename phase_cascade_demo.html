<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8"/>
  <title>Spring Layout Cascade</title>
  <style>
    body {
      font-family: sans-serif;
      margin: 20px;
    }
    #controls {
      margin-bottom: 10px;
    }
    #myCanvas {
      border: 1px solid #aaa;
      display: block;
      margin-top: 10px;
    }
  </style>
</head>
<body>
<h2>Spring Layout Network (Cascade Demo)</h2>
<div id="controls">
  <label for="numOsc">Number of Nodes:</label>
  <input type="number" id="numOsc" value="30" min="2" max="500" />
  
  <label for="prob">Connection Probability p:</label>
  <input type="number" id="prob" value="0.1" step="0.01" min="0" max="1" />
  
  <button id="initBtn">Initialize</button>
</div>
<canvas id="myCanvas" width="800" height="600"></canvas>

<script>
/**
 * Spring Layout + "Phase Cascade" Demo
 *
 * 1) We create an adjacency matrix with probability p.
 * 2) We run a simple force-directed (spring) layout so nodes are placed on-screen.
 * 3) All oscillators start in the same phase (fully synchronized).
 * 4) We run a discrete Kuramoto-like update rule over time.
 * 5) Clicking on any node sets its phase to a random value, causing a cascade of phase differences.
 */

let adjacencyMatrix = [];
let phases = [];
let positions = [];
let velocities = [];
let simInterval = null;
let numberOfOsc;
let connectionProbability;

const canvas = document.getElementById('myCanvas');
const ctx = canvas.getContext('2d');
const numOscInput = document.getElementById('numOsc');
const probInput = document.getElementById('prob');
const initBtn = document.getElementById('initBtn');

// Kuramoto simulation parameters
const dt = 0.03;            // discrete time-step
const coupling = 1;         // coupling strength
const updateIntervalMs = 50;  // ~20 FPS
const nodeRadius = 10;      // node draw radius

// Spring layout parameters
const layoutIterations = 500;   // # of iterations for force-directed layout
const kRepel = 5000;           // repulsive constant
const kAttract = 0.1;          // attractive constant for edges
const damping = 0.85;          // velocity damping factor

/**
 * createAdjacencyMatrix(numOsc, prob)
 * Return a numOsc x numOsc adjacency matrix with edges present with probability prob.
 */
function createAdjacencyMatrix(numOsc, prob) {
  const matrix = [];
  for (let i = 0; i < numOsc; i++) {
    matrix[i] = [];
    for (let j = 0; j < numOsc; j++) {
      matrix[i][j] = (i !== j && Math.random() < prob) ? 1 : 0;
    }
  }
  return matrix;
}

/**
 * runSpringLayout()
 * A simple force-directed layout:
 *  - Every pair of nodes repels each other
 *  - Edges provide an attractive (spring) force
 *  - After layoutIterations, positions[] stores final node coords
 */
function runSpringLayout() {
  // Random initial positions/velocities
  positions = [];
  velocities = [];
  for (let i = 0; i < numberOfOsc; i++) {
    positions[i] = {
      x: Math.random() * canvas.width,
      y: Math.random() * canvas.height
    };
    velocities[i] = { x: 0, y: 0 };
  }

  for (let iter = 0; iter < layoutIterations; iter++) {
    // Compute net forces
    const forces = [];
    for (let i = 0; i < numberOfOsc; i++) {
      forces[i] = { x: 0, y: 0 };
    }

    // Repulsion between all pairs
    for (let i = 0; i < numberOfOsc; i++) {
      for (let j = i + 1; j < numberOfOsc; j++) {
        const dx = positions[j].x - positions[i].x;
        const dy = positions[j].y - positions[i].y;
        const distSq = dx * dx + dy * dy || 0.0001;
        const dist = Math.sqrt(distSq);

        // Repulsive force ~ kRepel / dist^2
        const repForce = kRepel / distSq;

        // Normal direction
        const fx = repForce * (dx / dist);
        const fy = repForce * (dy / dist);

        forces[i].x -= fx;
        forces[i].y -= fy;
        forces[j].x += fx;
        forces[j].y += fy;
      }
    }

    // Attraction along edges
    for (let i = 0; i < numberOfOsc; i++) {
      for (let j = i + 1; j < numberOfOsc; j++) {
        if (adjacencyMatrix[i][j] === 1) {
          const dx = positions[j].x - positions[i].x;
          const dy = positions[j].y - positions[i].y;
          const dist = Math.sqrt(dx * dx + dy * dy) || 0.0001;

          // Attractive force ~ kAttract * dist
          const attForce = kAttract * dist;

          // Normal direction
          const fx = attForce * (dx / dist);
          const fy = attForce * (dy / dist);

          forces[i].x += fx;
          forces[i].y += fy;
          forces[j].x -= fx;
          forces[j].y -= fy;
        }
      }
    }

    // Update velocities & positions
    for (let i = 0; i < numberOfOsc; i++) {
      velocities[i].x = (velocities[i].x + forces[i].x) * damping;
      velocities[i].y = (velocities[i].y + forces[i].y) * damping;

      positions[i].x += velocities[i].x;
      positions[i].y += velocities[i].y;

      // Keep nodes within canvas bounds
      positions[i].x = Math.max(nodeRadius, Math.min(canvas.width - nodeRadius, positions[i].x));
      positions[i].y = Math.max(nodeRadius, Math.min(canvas.height - nodeRadius, positions[i].y));
    }
  }
}

/**
 * initPhasesSynchronized(numOsc)
 * Return an array of phases all set to 0, meaning fully synchronized.
 */
function initPhasesSynchronized(numOsc) {
  const p = [];
  for (let i = 0; i < numOsc; i++) {
    p[i] = 0; // all start in sync
  }
  return p;
}

/**
 * updatePhases()
 * Discrete Kuramoto-like update:
 *   θ_i(t+1) = θ_i(t) + dt * K * Σ A_ij * sin(θ_j - θ_i)
 */
function updatePhases() {
  const newPhases = [];
  for (let i = 0; i < numberOfOsc; i++) {
    let sumCoupling = 0;
    for (let j = 0; j < numberOfOsc; j++) {
      if (adjacencyMatrix[i][j] === 1) {
        sumCoupling += Math.sin(phases[j] - phases[i]);
      }
    }
    newPhases[i] = phases[i] + dt * coupling * sumCoupling;
  }
  phases = newPhases;
}

/**
 * drawNetwork()
 * Draw the network at the layout positions, color nodes by phase.
 */
function drawNetwork() {
  ctx.clearRect(0, 0, canvas.width, canvas.height);

  // Draw edges
  ctx.strokeStyle = 'rgba(0,0,0,0.1)';
  for (let i = 0; i < numberOfOsc; i++) {
    for (let j = i + 1; j < numberOfOsc; j++) {
      if (adjacencyMatrix[i][j] === 1) {
        ctx.beginPath();
        ctx.moveTo(positions[i].x, positions[i].y);
        ctx.lineTo(positions[j].x, positions[j].y);
        ctx.stroke();
      }
    }
  }

  // Draw nodes
  for (let i = 0; i < numberOfOsc; i++) {
    // Color by phase
    const hue = ((phases[i] * 180) / Math.PI) % 360;
    ctx.fillStyle = `hsl(${hue}, 100%, 50%)`;
    ctx.beginPath();
    ctx.arc(positions[i].x, positions[i].y, nodeRadius, 0, 2 * Math.PI);
    ctx.fill();
  }
}

/**
 * step()
 * Perform one simulation step: update phases, then redraw.
 */
function step() {
  updatePhases();
  drawNetwork();
}

/**
 * initializeNetwork()
 * 1) Create adjacency matrix
 * 2) Run spring layout to position nodes
 * 3) Set phases all to 0 (synchronized)
 * 4) Begin update loop
 */
function initializeNetwork() {
  if (simInterval) clearInterval(simInterval);

  numberOfOsc = parseInt(numOscInput.value, 10);
  connectionProbability = parseFloat(probInput.value);

  adjacencyMatrix = createAdjacencyMatrix(numberOfOsc, connectionProbability);
  runSpringLayout(); // get stable positions
  phases = initPhasesSynchronized(numberOfOsc);

  drawNetwork();
  simInterval = setInterval(step, updateIntervalMs);
}

/**
 * onCanvasClick(event)
 * If user clicks a node, we set its phase to a random value in [0, 2π).
 */
function onCanvasClick(event) {
  const rect = canvas.getBoundingClientRect();
  const mouseX = event.clientX - rect.left;
  const mouseY = event.clientY - rect.top;

  // Check each node to see if click is inside it
  for (let i = 0; i < numberOfOsc; i++) {
    const dx = mouseX - positions[i].x;
    const dy = mouseY - positions[i].y;
    const dist = Math.sqrt(dx*dx + dy*dy);
    if (dist <= nodeRadius) {
      // Kick this node's phase
      phases[i] = 2 * Math.PI * Math.random();
      // Re-draw immediately
      drawNetwork();
      break;
    }
  }
}

// Event listeners
initBtn.addEventListener('click', initializeNetwork);
canvas.addEventListener('click', onCanvasClick);

// Initialize once on load
initializeNetwork();
</script>
</body>
</html>
