<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8"/>
  <title>Spring Layout Oscillator Network</title>
  <style>
    body {
      font-family: sans-serif;
      margin: 20px;
    }
    #controls {
      margin-bottom: 10px;
    }
    #myCanvas {
      border: 1px solid #aaa;
      display: block;
      margin-top: 10px;
    }
  </style>
</head>
<body>
<h2>Spring Layout Oscillator Network</h2>
<div id="controls">
  <label for="numOsc">Number of Oscillators:</label>
  <input type="number" id="numOsc" value="30" min="2" max="500" />
  
  <label for="prob">Connection Probability p:</label>
  <input type="number" id="prob" value="0.1" step="0.01" min="0" max="1" />
  
  <button id="initBtn">Initialize</button>
</div>
<canvas id="myCanvas" width="800" height="600"></canvas>

<script>
/**
 * Spring Layout + Kuramoto-like Oscillator Dynamics
 *
 * 1) We create an adjacency matrix with a given probability p.
 * 2) We run a simple force-directed (spring) layout to find node positions.
 * 3) We simulate phases with a discrete Kuramoto-like update rule.
 * 4) We draw the network on each frame, coloring each node by its phase.
 */

let adjacencyMatrix = [];
let phases = [];
let positions = [];     // Node positions after spring layout
let velocities = [];    // For layout iteration
let simInterval = null;
let numberOfOsc;
let connectionProbability;

const canvas = document.getElementById('myCanvas');
const ctx = canvas.getContext('2d');
const numOscInput = document.getElementById('numOsc');
const probInput = document.getElementById('prob');
const initBtn = document.getElementById('initBtn');

// Kuramoto simulation parameters
const dt = 0.03;        // discrete time-step
const coupling = 1;     // coupling strength
const updateIntervalMs = 50; // ~20 FPS
const nodeRadius = 8;   // radius for each oscillator

// Spring layout parameters
const layoutIterations = 500;   // number of iterations to refine layout
const kRepel = 5000;            // repulsive constant (tweak as needed)
const kAttract = 0.1;           // attractive constant for edges
const damping = 0.85;           // velocity damping factor

/**
 * createAdjacencyMatrix(numOsc, prob)
 * Return a numOsc x numOsc adjacency matrix with edges present with probability prob.
 */
function createAdjacencyMatrix(numOsc, prob) {
  const matrix = [];
  for (let i = 0; i < numOsc; i++) {
    matrix[i] = [];
    for (let j = 0; j < numOsc; j++) {
      if (i === j) {
        matrix[i][j] = 0;
      } else {
        matrix[i][j] = Math.random() < prob ? 1 : 0;
      }
    }
  }
  return matrix;
}

/**
 * initPhases(numOsc)
 * Return an array of random phases in [0, 2π).
 */
function initPhases(numOsc) {
  const p = [];
  for (let i = 0; i < numOsc; i++) {
    p[i] = 2 * Math.PI * Math.random();
  }
  return p;
}

/**
 * runSpringLayout()
 * A simple force-directed layout:
 *  - For each pair of nodes, apply repulsive force
 *  - For each edge, apply attractive force
 *  - Update positions over layoutIterations
 *  This runs once to determine stable node placements.
 */
function runSpringLayout() {
  // Random initial positions/velocities
  positions = [];
  velocities = [];
  for (let i = 0; i < numberOfOsc; i++) {
    positions[i] = {
      x: Math.random() * canvas.width,
      y: Math.random() * canvas.height
    };
    velocities[i] = { x: 0, y: 0 };
  }

  for (let iter = 0; iter < layoutIterations; iter++) {
    // Compute forces
    const forces = [];
    for (let i = 0; i < numberOfOsc; i++) {
      forces[i] = { x: 0, y: 0 };
    }

    // Repulsion between all pairs of nodes
    for (let i = 0; i < numberOfOsc; i++) {
      for (let j = i + 1; j < numberOfOsc; j++) {
        const dx = positions[j].x - positions[i].x;
        const dy = positions[j].y - positions[i].y;
        const distSq = dx*dx + dy*dy || 0.0001; // avoid 0-dist
        const dist = Math.sqrt(distSq);

        // Repulsive force ~ kRepel / dist
        const repForce = kRepel / distSq;

        // Normalized direction
        const fx = repForce * (dx / dist);
        const fy = repForce * (dy / dist);

        forces[i].x -= fx;
        forces[i].y -= fy;
        forces[j].x += fx;
        forces[j].y += fy;
      }
    }

    // Attraction along edges
    for (let i = 0; i < numberOfOsc; i++) {
      for (let j = i + 1; j < numberOfOsc; j++) {
        if (adjacencyMatrix[i][j] === 1) {
          const dx = positions[j].x - positions[i].x;
          const dy = positions[j].y - positions[i].y;
          const dist = Math.sqrt(dx*dx + dy*dy) || 0.0001;

          // Attractive force ~ kAttract * dist
          // (classic spring force is k*(dist - some_length), here we assume restLength=0 for simplicity)
          const attForce = kAttract * (dist);

          // Normalized direction
          const fx = attForce * (dx / dist);
          const fy = attForce * (dy / dist);

          forces[i].x += fx;
          forces[i].y += fy;
          forces[j].x -= fx;
          forces[j].y -= fy;
        }
      }
    }

    // Update velocities & positions
    for (let i = 0; i < numberOfOsc; i++) {
      velocities[i].x = (velocities[i].x + forces[i].x) * damping;
      velocities[i].y = (velocities[i].y + forces[i].y) * damping;

      positions[i].x += velocities[i].x;
      positions[i].y += velocities[i].y;

      // Keep nodes within canvas bounds if desired (optional)
      // positions[i].x = Math.max(nodeRadius, Math.min(canvas.width - nodeRadius, positions[i].x));
      // positions[i].y = Math.max(nodeRadius, Math.min(canvas.height - nodeRadius, positions[i].y));
    }
  }
}

/**
 * updatePhases()
 * Discrete Kuramoto-like update:
 *   θ_i(t+1) = θ_i(t) + dt * K * Σ A_ij * sin(θ_j - θ_i)
 */
function updatePhases() {
  const newPhases = [];
  for (let i = 0; i < numberOfOsc; i++) {
    let sumCoupling = 0;
    for (let j = 0; j < numberOfOsc; j++) {
      if (adjacencyMatrix[i][j] === 1) {
        sumCoupling += Math.sin(phases[j] - phases[i]);
      }
    }
    newPhases[i] = phases[i] + dt * coupling * sumCoupling;
  }
  phases = newPhases;
}

/**
 * drawNetwork()
 * Draw the network using the spring layout positions. Color each node by phase.
 */
function drawNetwork() {
  ctx.clearRect(0, 0, canvas.width, canvas.height);

  // Draw edges
  ctx.strokeStyle = 'rgba(0, 0, 0, 0.1)';
  for (let i = 0; i < numberOfOsc; i++) {
    for (let j = i + 1; j < numberOfOsc; j++) {
      if (adjacencyMatrix[i][j] === 1) {
        ctx.beginPath();
        ctx.moveTo(positions[i].x, positions[i].y);
        ctx.lineTo(positions[j].x, positions[j].y);
        ctx.stroke();
      }
    }
  }

  // Draw nodes
  for (let i = 0; i < numberOfOsc; i++) {
    const hue = ((phases[i] * 180) / Math.PI) % 360;
    ctx.fillStyle = `hsl(${hue}, 100%, 50%)`;
    ctx.beginPath();
    ctx.arc(positions[i].x, positions[i].y, nodeRadius, 0, 2 * Math.PI);
    ctx.fill();
  }
}

/**
 * step()
 * Perform one simulation step: update phases, then redraw.
 */
function step() {
  updatePhases();
  drawNetwork();
}

/**
 * initializeNetwork()
 * 1) Create adjacency matrix
 * 2) Run spring layout to find positions
 * 3) Randomize phases
 * 4) Start update loop
 */
function initializeNetwork() {
  if (simInterval) clearInterval(simInterval);

  numberOfOsc = parseInt(numOscInput.value, 10);
  connectionProbability = parseFloat(probInput.value);

  adjacencyMatrix = createAdjacencyMatrix(numberOfOsc, connectionProbability);
  runSpringLayout(); // find stable positions
  phases = initPhases(numberOfOsc);

  drawNetwork();
  simInterval = setInterval(step, updateIntervalMs);
}

// Event listener for initialization
initBtn.addEventListener('click', initializeNetwork);

// Initialize once on load
initializeNetwork();
</script>
</body>
</html>
