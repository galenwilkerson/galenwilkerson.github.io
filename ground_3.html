<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Drones in Transparent Box</title>
<style>
  body{margin:0;overflow:hidden;background:#000;font-family:sans-serif}
  #ui{position:fixed;top:10px;left:10px;z-index:10;color:#fff}
  input[type=range]{vertical-align:middle}
</style>
</head>
<body>
<div id="ui">
  <label># drones (3â€“10)&nbsp;
    <input id="droneCount" type="range" min="3" max="10" value="5">
  </label>
  <span id="countLabel">5</span>
</div>

<script src="https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.min.js"></script>
<script>
/* ------------------------------------------------------------------ */
/*  CONSTANTS                                                         */
/* ------------------------------------------------------------------ */
const GROUND_TEXTURE = 'ground_2.png';  // image must be in same directory
const BOX_SIZE       = 20;              // width/depth of box in world units
const BOX_HEIGHT     = 10;              // wall height
const BRIGHTEN_ALPHA = 0.30;            // 0 = original, 1 = full white overlay

const STATION_RADIUS = 4;               // red circle radius
const DRONE_DOT_RAD  = 0.3;             // visual size of drone sphere
const HOR_SPEED_MAX  = 0.06;            // max horizontal speed
const VER_SPEED_MAX  = 0.04;            // max vertical speed

/* ------------------------------------------------------------------ */
/*  RENDERER, SCENE, CAMERA                                           */
/* ------------------------------------------------------------------ */
const renderer = new THREE.WebGLRenderer({antialias:true});
renderer.setPixelRatio(devicePixelRatio);
renderer.setSize(innerWidth, innerHeight);
renderer.outputEncoding = THREE.sRGBEncoding;
document.body.appendChild(renderer.domElement);

const scene = new THREE.Scene();
scene.add(new THREE.AmbientLight(0xffffff, 0.9));

const camera = new THREE.PerspectiveCamera(50, innerWidth/innerHeight, 0.1, 1000);
camera.position.set(25, 18, 25);
camera.lookAt(0, 0, 0);

/* ------------------------------------------------------------------ */
/*  GROUND + TRANSPARENT WALLS                                        */
/* ------------------------------------------------------------------ */
new THREE.TextureLoader().load(GROUND_TEXTURE, texture => {
  brightenTexture(texture);
  buildBox(texture);
  init();                      // start once texture ready
});

/* brighten by drawing translucent white over original */
function brightenTexture(tex){
  const img = tex.image;
  const c   = document.createElement('canvas');
  c.width = img.width; c.height = img.height;
  const ctx = c.getContext('2d');
  ctx.drawImage(img, 0, 0);
  ctx.fillStyle = `rgba(255,255,255,${BRIGHTEN_ALPHA})`;
  ctx.fillRect(0, 0, c.width, c.height);
  tex.image = c;
  tex.needsUpdate = true;
  tex.encoding = THREE.sRGBEncoding;
}

function buildBox(tex){
  /* ground */
  const ground = new THREE.Mesh(
    new THREE.PlaneGeometry(BOX_SIZE, BOX_SIZE),
    new THREE.MeshBasicMaterial({map: tex})
  );
  ground.rotation.x = -Math.PI/2;
  scene.add(ground);

  /* three transparent walls (front side open) */
  const wallMat = new THREE.MeshBasicMaterial({
    color: 0x888888, opacity: 0.15, transparent: true, side: THREE.DoubleSide
  });
  const wallGeo = new THREE.PlaneGeometry(BOX_SIZE, BOX_HEIGHT);

  const back = new THREE.Mesh(wallGeo, wallMat);
  back.position.set(0, BOX_HEIGHT/2, -BOX_SIZE/2);
  scene.add(back);

  const left = new THREE.Mesh(wallGeo, wallMat);
  left.rotation.y =  Math.PI/2;
  left.position.set(-BOX_SIZE/2, BOX_HEIGHT/2, 0);
  scene.add(left);

  const right = new THREE.Mesh(wallGeo, wallMat);
  right.rotation.y = -Math.PI/2;
  right.position.set( BOX_SIZE/2, BOX_HEIGHT/2, 0);
  scene.add(right);
}

/* ------------------------------------------------------------------ */
/*  UI SLIDER                                                         */
/* ------------------------------------------------------------------ */
const slider   = document.getElementById('droneCount');
const labelVal = document.getElementById('countLabel');
slider.oninput = () => { labelVal.textContent = slider.value; resetDrones(+slider.value); };

/* ------------------------------------------------------------------ */
/*  DRONES & GROUND STATIONS                                          */
/* ------------------------------------------------------------------ */
const dronesGroup = new THREE.Group();     // holds moving drones
scene.add(dronesGroup);                    // rings stay directly in scene
let drones = [];                           // {mesh, base:Vector3, vx, vy, vz}

function makeStationRing() {
  const g = new THREE.RingGeometry(STATION_RADIUS * 0.97, STATION_RADIUS, 64);
  g.rotateX(-Math.PI / 2);
  return new THREE.Mesh(
    g,
    new THREE.MeshBasicMaterial({ color: 0xff0000, side: THREE.DoubleSide })
  );
}

function makeDroneDot() {
  return new THREE.Mesh(
    new THREE.SphereGeometry(DRONE_DOT_RAD, 8, 8),
    new THREE.MeshBasicMaterial({ color: 0xffffff })
  );
}

function resetDrones(n) {
  dronesGroup.clear();
  // remove old rings (children with ring.geometry.type === 'RingGeometry')
  scene.children = scene.children.filter(obj => !(obj.geometry && obj.geometry.type === 'RingGeometry'));

  drones = [];
  const half = BOX_SIZE/2 - STATION_RADIUS;

  for (let i = 0; i < n; i++) {
    /* ---- create ground station ---- */
    const ring = makeStationRing();
    ring.position.set(
      THREE.MathUtils.randFloat(-half, half),
      0.02,                                      // small lift to avoid z-fighting
      THREE.MathUtils.randFloat(-half, half)
    );
    scene.add(ring);

    /* ---- drone ---- */
    const drone = makeDroneDot();
    drone.position.copy(ring.position);
    drone.position.y = 2;                        // start 2 units above ground
    dronesGroup.add(drone);

    drones.push({
      mesh: drone,
      base: ring.position.clone(),
      vx:   (Math.random()*2 - 1) * HOR_SPEED_MAX,
      vy:   (Math.random()*2 - 1) * VER_SPEED_MAX,
      vz:   (Math.random()*2 - 1) * HOR_SPEED_MAX
    });
  }
}

/* ------------------------------------------------------------------ */
/*  INITIALISE & ANIMATE                                              */
/* ------------------------------------------------------------------ */
function init(){
  resetDrones(+slider.value);
  animate();
}

function animate(){
  requestAnimationFrame(animate);
  updateDrones();
  renderer.render(scene, camera);
}

function updateDrones(){
  for (const d of drones){
    const p = d.mesh.position;
    /* advance */
    p.x += d.vx; p.y += d.vy; p.z += d.vz;

    /* vertical bounds */
    if (p.y < 0.5 || p.y > BOX_HEIGHT - 0.5) d.vy *= -1;

    /* circle bounds in x-z plane relative to base */
    const dx = p.x - d.base.x;
    const dz = p.z - d.base.z;
    const r2 = dx*dx + dz*dz;
    const maxR2 = STATION_RADIUS * STATION_RADIUS;
    if (r2 > maxR2){
      /* reflect horizontal velocity & step back */
      d.vx *= -1; d.vz *= -1;
      p.x += d.vx; p.z += d.vz;
    }
  }
}

/* ------------------------------------------------------------------ */
/*  RESIZE HANDLER                                                    */
/* ------------------------------------------------------------------ */
addEventListener('resize', () => {
  camera.aspect = innerWidth / innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(innerWidth, innerHeight);
});
</script>
</body>
</html>
