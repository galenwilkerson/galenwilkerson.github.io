<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Drones - Ground Box</title>
<style>
  body{margin:0;overflow:hidden;background:#000;font-family:sans-serif}
  #ui{position:fixed;top:10px;left:10px;z-index:10;color:#fff}
</style>
</head>
<body>
<div id="ui">
  <label># drones 3-10 
    <input id="count" type="range" min="3" max="10" value="5" step="1">
  </label>
  <span id="val">5</span>
</div>

<script src="https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.min.js"></script>
<script>
/* ---------- constants ---------- */
const GROUND_TEXTURE = 'ground_2.png';   // same directory
const BOX_SIZE       = 20;               // x,z width/depth
const BOX_HEIGHT     = 10;               // wall height
const DRONE_RADIUS   = 1.2;              // world units
const BRIGHTEN_ALPHA = 0.3;              // 0-1 extra white over texture

/* ---------- renderer / scene / camera ---------- */
const renderer = new THREE.WebGLRenderer({antialias:true});
renderer.setPixelRatio(devicePixelRatio);
renderer.setSize(innerWidth,innerHeight);
renderer.shadowMap.enabled = false;
document.body.appendChild(renderer.domElement);

const scene = new THREE.Scene();
scene.add(new THREE.AmbientLight(0xffffff,0.8));

const cam = new THREE.PerspectiveCamera(50,innerWidth/innerHeight,0.1,1000);
cam.position.set(25,18,25);
cam.lookAt(0,0,0);

/* ---------- ground + walls ---------- */
new THREE.TextureLoader().load(GROUND_TEXTURE, tex=>{
  brightenTexture(tex);
  buildBox(tex);
  resetDrones(+slider.value);               // start animation after texture ready
  animate();
});

/* brighten texture by overlaying translucent white */
function brightenTexture(texture){
  const img = texture.image;
  const cvs = document.createElement('canvas');
  cvs.width = img.width; cvs.height = img.height;
  const ctx = cvs.getContext('2d');
  ctx.drawImage(img,0,0);
  ctx.fillStyle = `rgba(255,255,255,${BRIGHTEN_ALPHA})`;
  ctx.fillRect(0,0,cvs.width,cvs.height);
  texture.image = cvs;
  texture.needsUpdate = true;
  texture.encoding    = THREE.sRGBEncoding;
}

/* build bottom plane + three side walls (front open) */
function buildBox(tex){
  /* ground */
  const ground = new THREE.Mesh(
    new THREE.PlaneGeometry(BOX_SIZE,BOX_SIZE),
    new THREE.MeshBasicMaterial({map:tex})
  );
  ground.rotation.x = -Math.PI/2;
  scene.add(ground);

  const wallMat = new THREE.MeshBasicMaterial({color:0x555555,side:THREE.DoubleSide});
  const wallGeo = new THREE.PlaneGeometry(BOX_SIZE,BOX_HEIGHT);

  const back = new THREE.Mesh(wallGeo,wallMat);
  back.position.set(0,BOX_HEIGHT/2,-BOX_SIZE/2);
  scene.add(back);

  const left = new THREE.Mesh(wallGeo,wallMat);
  left.rotation.y =  Math.PI/2;
  left.position.set(-BOX_SIZE/2,BOX_HEIGHT/2,0);
  scene.add(left);

  const right = new THREE.Mesh(wallGeo,wallMat);
  right.rotation.y = -Math.PI/2;
  right.position.set( BOX_SIZE/2,BOX_HEIGHT/2,0);
  scene.add(right);
}

/* ---------- drones ---------- */
const dronesGroup = new THREE.Group();
scene.add(dronesGroup);
const slider = document.getElementById('count');
const valLbl = document.getElementById('val');

slider.oninput = ()=>{ valLbl.textContent = slider.value; resetDrones(+slider.value); };

function resetDrones(n){
  dronesGroup.clear();
  drones = [];
  for(let i=0;i<n;i++){
    const ring = makeRing();
    dronesGroup.add(ring);
    drones.push({
      mesh: ring,
      vx:  (Math.random()*2-1)*0.08,
      vz:  (Math.random()*2-1)*0.08
    });
    randomPosition(ring);
  }
}

function makeRing(){
  const g = new THREE.RingGeometry(DRONE_RADIUS*0.94,DRONE_RADIUS,32);
  g.rotateX(-Math.PI/2);
  return new THREE.Mesh(
    g,
    new THREE.MeshBasicMaterial({color:0xff0000,side:THREE.DoubleSide})
  );
}

function randomPosition(mesh){
  const half = BOX_SIZE/2 - DRONE_RADIUS;
  mesh.position.set(
    THREE.MathUtils.randFloatSpread(half*2),
    0.01,                                   // slight lift to avoid z-fight
    THREE.MathUtils.randFloatSpread(half*2)
  );
}

/* ---------- animation ---------- */
let drones=[];

function animate(){
  requestAnimationFrame(animate);
  updateDrones();
  renderer.render(scene,cam);
}

function updateDrones(){
  const min = -BOX_SIZE/2 + DRONE_RADIUS;
  const max =  BOX_SIZE/2 - DRONE_RADIUS;
  for(const d of drones){
    const p = d.mesh.position;
    p.x += d.vx;
    p.z += d.vz;
    if(p.x<min||p.x>max) d.vx*=-1;
    if(p.z<min||p.z>max) d.vz*=-1;
  }
}

/* ---------- resize ---------- */
addEventListener('resize',()=>{
  cam.aspect = innerWidth/innerHeight;
  cam.updateProjectionMatrix();
  renderer.setSize(innerWidth,innerHeight);
});
</script>
</body>
</html>
